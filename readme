Lý thuyết react nâng cao: 
I. Hook
1. useState
    - Để quản lý trạng thái cục bộ, giúp component nhớ dữ liệu và cập nhật lại giao diện khi dữ liệu thay đổi
    - Cú pháp: 
        const [state, setState] = useState(initialValue)
        + initialValue: là giá trị bạn đầu
         Số (0)
         Mảng ([])
         Input ('')
         Object ([{}])

2. useEffect
    - Dùng để xử lý side effect trong function component 
        + side effect là những việc xảy ra ngoài việc render UI
         Call API
         Thao tác DOM
         Lắng nghe sự kiện(event listener)
         Set timeout/interval
         Đồng bộ dữ liệu với localStorage
    - Cú pháp
    useEffect(() => {
        return () => {
        }
    }, [dependency])
    + callback: hàm chứa side-effect
    + dependencies: mảng các giá trị mà khi thay đổi → effect chạy lại
    
    useEffect(() => {
        fetch("api")
            .then(res => res.json())
            .then(data => setTodos(data)) 
        }
    }, [])

    - Mảng dependencies chạy khi: 
    useEffect(callback): Mỗi lần render
    useEffect(callback, []): chỉ một lần khi mount
    useEffect(callback, [a, b]): khi a hoặc b thay đổi
    Cleanup(return () => {}): Khi unmount hoặc effect chạy lại 
        Mount là khoảnh khắc component được tạo ra 
        Unmount là khoảnh khắc component bị biến mất

3. useRef là một React hook tạo ra thuộc tính .current
    - Giá trị trong ref.current không làm component re-render khi thay đổi
    - useRef dùng để lưu các giá trị qua nhiều render mà không mất dữ liệu
    - Cách dùng useRef: 
        Dùng như document.getElementById
        Lưu giá trị mà không gây re-render
        Lưu previous value(giá trị trước đó)
        Lưu timer(setInterval)
    - Cú pháp 
        const myRef = useRef(initialValue)
        current: initialValue
        gọi: myRef.current 

4. useMemo là một React hook dùng để ghi nhớ (memoize) kết quả của một phép tính tốn kém để tránh
tính lại không cần thiết mỗi lần giao diện re-render
    - nó giúp tôi ưu performance
    - Dùng useMemo khi 
        có phép tính nặng(sort, loop lớn, tính toán phức tạp)
        Có object/array truyền xuống component con(tránh render lại không cần thiết)
        Do mình có nhu cầu giảm số lần tính lại một giá trị dựa trên state/props
    - Cú pháp
        const memoValue = useMemo(() => {
        return value
        }, [dependencies])
        Chỉ tính lại khi dependencies thay đổi

5. useCallback là một React hook dùng để ghi nhớ một hàm, giúp không tạo lại hàm mới khi component
thay đổi
    - Dùng useCallback để: 
        Tránh component con re-render mà không cần thiết
        Giữ hàm ổn định khi truyền vào
        Giảm chi phí khi callback được tạo lại liên tục

    - Cú pháp
        const memoizedCallback = useCallback(() => {
            do something
        }, [dependencies])
        React chỉ tạo lại hàm mới khi dependencies thay đổi

II. Lifecycle component
                ┌───────────────────────────────┐
                │     COMPONENT MOUNT (xuất hiện)│
                └───────────────────────────────┘
                                │
                                ▼
                    Render lần đầu (initial render)
                                │
                                ▼
                  useEffect(() => {...}, []) 
                        (chạy 1 lần)
                → Thường dùng: fetch API, add event listener
                                │
                                ▼
          ┌─────────────────────────────────────────────────┐
          │                UPDATE PHASE                     │
          └─────────────────────────────────────────────────┘
                                │
                Mỗi lần State / Props thay đổi → Re-render
                                │
                                ▼
                  useEffect(() => {...}, [deps])
               (chạy mỗi khi deps thay đổi)
                                │
                                ▼
     ┌──────────────────────────────────────────────────────────┐
     │ Nếu deps thay đổi → chạy cleanup của effect trước đó     │
     │   return () => { ... cleanup ... }                       │
     └──────────────────────────────────────────────────────────┘
                                │
                                ▼
          ┌─────────────────────────────────────────────────┐
          │           COMPONENT UNMOUNT (biến mất)          │
          └─────────────────────────────────────────────────┘
                                │
                                ▼
          useEffect(() => {...}, []) cleanup chạy:
                 return () => { ... }
 → Remove event listener, clear interval, disconnect websocket

III. React Router DOM là một thư viện giúp Routing(điều hướng trang) trong ứng dụng react
    - Nó giúp chuyển trang không bị reload lại toàn bộ website
        Tạo SPA(Single page application)
        Mỗi Url tương ứng với một component
        Điều hướng bằng code (useNavigate) hoặc thẻ Link
    - Dùng để
        Tạo nhiều trang
        Điều hướng khi người dùng click link hoặc các button chuyển trang
        Sinh url tự động 
        Bảo về route (Phân quyền)
    - Cách dùng
        + Cài đặt : npm install react-router-dom
        + Cấu hình cho router: 
            ReactDOM.createRoot(document.getElementById("root")).render(
                <BrowserRouter>
                    <App />
                </BrowserRouter>
            )
            Bọc bằng thẻ <BrowserRouter> trong main.tsx
    - Link dùng khi: 
        Người dùng click chuyển trang
        Điều hướng xuất hiện trong UI(button, menu, ...)
        Bạn muốn SEO tốt hơn (Link tạo thẻ a thật trong DOM)
    - useNavigate dùng khi: 
        Cần chuyển trang bằng code không cần click
        const navigate = useNavigate()

IV. Controlled, Uncontrolled, Formik/yup
1. Controlled component: là Form được react kiểm soát qua state(useState)
Mỗi lần gõ thì state thay đổi và giao diện cũng thay đổi theo

2. Uncontrolled components: là Form không dùng state mà dùng ref(useRef) 
để lấy giá trị khi submit

V. React Formik/yup
- Yup là thư viện validate 
- Formik là một thư viện giúp quản lý form tốt trong react dễ hơn rất nhiều sơ với useState 
- Formik giúp xử lý: 
    Quản lý state của form
    Validate
    Xử lý submit
    Hiển thị lỗi 
    Làm việc tốt với yup(thư viện validate)
- Cách formik hoạt động: 
    Formik sử dụng mô hình
        + initialValues: giá trị khởi tạo 
        + handleChange: cập nhật value khi nhập 
        + handleSubmit: Xử lý submit 
        + error + touched: Quản lý lỗi và hiển thị lỗi
        + Dùng yup để validate form
        * Bên trong formik có một state riêng để theo dõi dữ liệu của form, không cần tạo useState thủ công
    * Khi dùng <Formik/>
        + Nó sẽ tạo một state để lưu 
            values: { name: "", email: "" }
            errors: {}
            touched: {}
        + Khi gõ vào Field
            Formik sẽ tự động  
                lấy giá trị mới
                Cập nhật state value
                validate bằng Yup 
                Nếu sai -> cập nhật error
                Nếu blur input -> cập nhật touched
        + Khi click submit
            Formik gọi validationSchema
            Nếu có lỗi -> không submit 
            Nếu không lỗi -> gọi onSubmit(values)
- Cách dùng formik 
    + Cài đặt: npm install formik yup

VI. Redux cơ bản
Redux là một thư viện quản lý state toàn cục cho ứng dụng JavaScript
    - Giúp quản lý state phức tạp
    - Dữ liệu được lưu trữ tập trung trong store
    - Dữ liệu trong store có thể được truy cập từ bất kỳ component nào 
    - Dữ liệu trong store chỉ có thể được thay đổi thông qua actions và reducers
    -Redux phù hợp với các ứng dụng lơn, có nhiều component cần chia sẻ dữ liệu
    - Redux giúp tách biệt logic quản lý state khỏi UI, làm code dễ bảo trì hơn
- Cách dùng Redux
    + Cài đặt: npm install redux react-redux @reduxjs/toolkit
    + Tạo store: Nơi lưu trữ state toàn cục
    + Tạo slice: Chứa reducers và actions
    + Cung cập store cho ứng dụng bằng <Provider>
    + Sử dụng useSelector để lấy state từ store
    + Sử dụng useDispatch để gửi actions thay đổi state

- Redux có 3 phần chính
    + Store: Nơi lưu trũ state tonaf cục ứng dụng
    + Actions: Đối tượng mô tả hành động thay đổi state
    + Reducers: Hàm nhận staet hiện tại và action để trả về state mới
